import { z } from "zod"

export const inputParams = {
  "boards": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `boards` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/boards\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "field": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `field` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/field\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Defines the payload for the fields, screens, screen schemes, issue type screen schemes, field layouts, and field layout schemes</property-description>").optional(),
  "issueType": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `issueType` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/issueType\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The payload for creating issue types in a project</property-description>").optional(),
  "notification": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `notification` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/notification\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The payload for creating a notification scheme. The user has to supply the ID for the default notification scheme. For CMP this is provided in the project payload and should be left empty, for TMP it's provided using this payload</property-description>").optional(),
  "permissionScheme": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `permissionScheme` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/permissionScheme\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The payload to create a permission scheme</property-description>").optional(),
  "project": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `project` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/project\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The payload for creating a project</property-description>").optional(),
  "role": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `role` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/role\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "scope": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `scope` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/scope\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The payload for creating a scope. Defines if a project is team-managed project or company-managed project</property-description>").optional(),
  "security": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `security` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/security\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The payload for creating a security scheme. See https://support.atlassian.com/jira-cloud-administration/docs/configure-issue-security-schemes/</property-description>").optional(),
  "workflow": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `workflow` to the tool, first call the tool `expandSchema` with \"/properties/template/properties/workflow\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>The payload for creating a workflows. See https://www.atlassian.com/software/jira/guides/workflows/overview\\#what-is-a-jira-workflow</property-description>").optional()
}