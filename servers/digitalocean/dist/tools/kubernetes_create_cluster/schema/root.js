import { z } from "zod";
export const inputParams = {
    "id": z.string().uuid().describe("A unique ID that can be used to identify and reference a Kubernetes cluster.").readonly().optional(),
    "name": z.string().describe("A human-readable name for a Kubernetes cluster."),
    "region": z.string().describe("The slug identifier for the region where the Kubernetes cluster is located."),
    "version": z.string().describe("The slug identifier for the version of Kubernetes used for the cluster. If set to a minor version (e.g. \"1.14\"), the latest version within it will be used (e.g. \"1.14.6-do.1\"); if set to \"latest\", the latest published version will be used. See the `/v2/kubernetes/options` endpoint to find all currently available versions."),
    "cluster_subnet": z.string().describe("The range of IP addresses for the overlay network of the Kubernetes cluster in CIDR notation.").optional(),
    "service_subnet": z.string().describe("The range of assignable IP addresses for services running in the Kubernetes cluster in CIDR notation.").optional(),
    "vpc_uuid": z.string().uuid().describe("A string specifying the UUID of the VPC to which the Kubernetes cluster is assigned.").optional(),
    "ipv4": z.string().describe("The public IPv4 address of the Kubernetes master node. This will not be set if high availability is configured on the cluster (v1.21+)").readonly().optional(),
    "endpoint": z.string().describe("The base URL of the API server on the Kubernetes master node.").readonly().optional(),
    "tags": z.array(z.string()).describe("An array of tags applied to the Kubernetes cluster. All clusters are automatically tagged `k8s` and `k8s:$K8S_CLUSTER_ID`.").optional(),
    "node_pools": z.array(z.string()).describe("An object specifying the details of the worker nodes available to the Kubernetes cluster."),
    "maintenance_policy": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `maintenance_policy` to the tool, first call the tool `expandSchema` with \"/properties/maintenance_policy\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>An object specifying the maintenance window policy for the Kubernetes cluster.</property-description>").optional(),
    "auto_upgrade": z.boolean().describe("A boolean value indicating whether the cluster will be automatically upgraded to new patch releases during its maintenance window.").optional(),
    "status": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `status` to the tool, first call the tool `expandSchema` with \"/properties/status\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>An object containing a `state` attribute whose value is set to a string indicating the current status of the cluster.</property-description>").optional(),
    "created_at": z.string().datetime({ offset: true }).describe("A time value given in ISO8601 combined date and time format that represents when the Kubernetes cluster was created.").readonly().optional(),
    "updated_at": z.string().datetime({ offset: true }).describe("A time value given in ISO8601 combined date and time format that represents when the Kubernetes cluster was last updated.").readonly().optional(),
    "surge_upgrade": z.boolean().describe("A boolean value indicating whether surge upgrade is enabled/disabled for the cluster. Surge upgrade makes cluster upgrades fast and reliable by bringing up new nodes before destroying the outdated nodes.").optional(),
    "ha": z.boolean().describe("A boolean value indicating whether the control plane is run in a highly available configuration in the cluster. Highly available control planes incur less downtime. The property cannot be disabled.").optional(),
    "registry_enabled": z.boolean().describe("A read-only boolean value indicating if a container registry is integrated with the cluster.").readonly().optional(),
    "control_plane_firewall": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `control_plane_firewall` to the tool, first call the tool `expandSchema` with \"/properties/control_plane_firewall\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>An object specifying the control plane firewall for the Kubernetes cluster. Control plane firewall is in early availability (invite only).</property-description>").optional(),
    "cluster_autoscaler_configuration": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `cluster_autoscaler_configuration` to the tool, first call the tool `expandSchema` with \"/properties/cluster_autoscaler_configuration\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>An object specifying custom cluster autoscaler configuration.</property-description>").optional(),
    "routing_agent": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `routing_agent` to the tool, first call the tool `expandSchema` with \"/properties/routing_agent\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>An object specifying whether the routing-agent component should be enabled for the Kubernetes cluster.</property-description>").optional()
};
