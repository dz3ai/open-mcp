import { z } from "zod"

export const inputParamsSchema = {
  "frequency_penalty": z.number().gte(-2).lte(2).describe("Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.").optional(),
  "logprobs": z.boolean().describe("Whether to include log probabilities in the response. This is not supported by all models.").optional(),
  "max_completion_tokens": z.number().int().describe("An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens.").optional(),
  "max_temp": z.number().gte(0).lte(2).describe("Maximum temperature value for dynamic temperature scaling.").optional(),
  "max_tokens": z.number().int().describe("The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API. This value is now deprecated in favor of max_completion_tokens.").optional(),
  "messages": z.array(z.union([z.object({ "content": z.union([z.string(), z.array(z.object({ "text": z.string().min(1).describe("The prompt text of the message. Must be at-least one character in length"), "type": z.literal("text") }).strict().describe("Text message type."))]), "role": z.literal("user") }).describe("The user message is the input from the user. It is part of the conversation and is visible to the assistant."), z.object({ "content": z.union([z.string(), z.array(z.object({ "text": z.string().min(1).describe("The prompt text of the message. Must be at-least one character in length"), "type": z.literal("text") }).strict().describe("Text message type.")), z.any().nullable()]), "name": z.string().optional(), "reasoning_content": z.string().nullable().optional(), "role": z.literal("assistant"), "tool_calls": z.array(z.any().nullable()).optional() }).describe("The assistant message contains the response from the LLM."), z.object({ "content": z.string(), "name": z.string().optional(), "reasoning_content": z.string().nullable().optional(), "role": z.literal("tool"), "tool_call_id": z.string(), "tool_calls": z.array(z.any().nullable()).optional() }).describe("The tool message is a special message that is used to call a tool. It is not part of the conversation and is not visible to the user."), z.object({ "content": z.union([z.string(), z.array(z.object({ "text": z.string().min(1).describe("The prompt text of the message. Must be at-least one character in length"), "type": z.literal("text") }).strict().describe("Text message type."))]), "name": z.string().optional(), "role": z.literal("system") }).describe("The system message is a special message that provides context to the model. It is not part of the conversation and is not visible to the user.")])).min(1).describe("A list of messages comprising the conversation so far. Depending on the model you use, different message types (modalities) are supported, like text and images. For compatibility purposes, the schema supports submitting multiple image_url messages, however, only the last image_url message will be passed to and processed by the model."),
  "min_p": z.number().gte(0).lte(1).describe("Sets a minimum probability threshold for token selection. Tokens with probabilities below this value are filtered out.").optional(),
  "min_temp": z.number().gte(0).lte(2).describe("Minimum temperature value for dynamic temperature scaling.").optional(),
  "model": z.string().describe("The ID of the model you wish to prompt. May also be a model trait, or a compatibility mapping. See the models endpoint for a list of models available to you.  You can use feature suffixes to enable features from the venice_parameters object. Please see \"Model Feature Suffix\" documentation for more details."),
  "n": z.number().int().describe("How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.").optional(),
  "presence_penalty": z.number().gte(-2).lte(2).describe("Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.").optional(),
  "repetition_penalty": z.number().gte(0).describe("The parameter for repetition penalty. 1.0 means no penalty. Values > 1.0 discourage repetition.").optional(),
  "seed": z.number().int().gt(0).describe("The random seed used to generate the response. This is useful for reproducibility.").optional(),
  "stop": z.union([z.string(), z.array(z.string()).min(1).max(4), z.any().nullable()]).describe("Up to 4 sequences where the API will stop generating further tokens. Defaults to null.").optional(),
  "stop_token_ids": z.array(z.number()).describe("Array of token IDs where the API will stop generating further tokens.").optional(),
  "stream": z.boolean().describe("Whether to stream back partial progress. Defaults to false.").optional(),
  "stream_options": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `stream_options` to the tool, first call the tool `expandSchema` with \"/properties/stream_options\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>").optional(),
  "temperature": z.number().gte(0).lte(2).describe("What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or top_p but not both.").optional(),
  "top_k": z.number().int().gte(0).describe("The number of highest probability vocabulary tokens to keep for top-k-filtering.").optional(),
  "top_p": z.number().gte(0).lte(1).describe("An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.").optional(),
  "user": z.string().describe("This field is discarded on the request but is supported in the Venice API for compatibility with OpenAPI clients.").optional(),
  "venice_parameters": z.record(z.any()).describe("<llm-instruction>This part of the input schema is truncated. If you want to pass the property `venice_parameters` to the tool, first call the tool `expandSchema` with \"/properties/venice_parameters\" in the list of pointers. This will return the expanded input schema which you can then use in the tool call. You may have to call `expandSchema` multiple times if the schema is nested.</llm-instruction>\n<property-description>Unique parameters to Venice's API implementation.</property-description>").optional(),
  "parallel_tool_calls": z.boolean().describe("Whether to enable parallel function calling during tool use.").optional(),
  "response_format": z.object({ "json_schema": z.record(z.any().nullable()), "type": z.literal("json_schema") }).strict().describe("The JSON Schema that should be used to validate and format the response.").describe("Format in which the response should be returned.").optional(),
  "tool_choice": z.union([z.object({ "function": z.object({ "name": z.string() }).strict(), "type": z.string() }).strict(), z.string()]).optional(),
  "tools": z.array(z.object({ "function": z.object({ "description": z.string().optional(), "name": z.string(), "parameters": z.record(z.any().nullable()).optional() }).strict(), "id": z.string().optional(), "type": z.string().optional() }).describe("A tool that can be called by the model. Currently, only functions are supported as tools.")).nullable().describe("A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.").optional(),
  "Accept-Encoding": z.string().describe("Supported compression encodings (gzip, br). Only applied when stream is false.").optional()
}