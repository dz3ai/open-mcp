import { z } from "zod"

export const toolName = `get_events`
export const toolDescription = `List user and enterprise events`
export const baseUrl = `https://api.box.com/2.0`
export const path = `/events`
export const method = `get`
export const security = [
  {
    "key": "Authorization",
    "value": "Bearer <mcp-env-var>OAUTH2_TOKEN</mcp-env-var>",
    "in": "header",
    "envVarName": "OAUTH2_TOKEN",
    "schemeType": "oauth2"
  }
]

export const inputParams = z.object({ "query": z.object({ "stream_type": z.enum(["all","changes","sync","admin_logs","admin_logs_streaming"]).describe("Defines the type of events that are returned\n\n* `all` returns everything for a user and is the default\n* `changes` returns events that may cause file tree changes\n  such as file updates or collaborations.\n* `sync` is similar to `changes` but only applies to synced folders\n* `admin_logs` returns all events for an entire enterprise and\n  requires the user making the API call to have admin permissions. This\n  stream type is for programmatically pulling from a 1 year history of\n  events across all users within the enterprise and within a\n  `created_after` and `created_before` time frame. The complete history\n  of events will be returned in chronological order based on the event\n  time, but latency will be much higher than `admin_logs_streaming`.\n* `admin_logs_streaming` returns all events for an entire enterprise and\n  requires the user making the API call to have admin permissions. This\n  stream type is for polling for recent events across all users within\n  the enterprise. Latency will be much lower than `admin_logs`, but\n  events will not be returned in chronological order and may\n  contain duplicates."), "stream_position": z.string().describe("The location in the event stream to start receiving events from.\n\n* `now` will return an empty list events and\nthe latest stream position for initialization.\n* `0` or `null` will return all events.").optional(), "limit": z.number().int().lte(500).describe("Limits the number of events returned\n\nNote: Sometimes, the events less than the limit requested can be returned\neven when there may be more events remaining. This is primarily done in\nthe case where a number of events have already been retrieved and these\nretrieved events are returned rather than delaying for an unknown amount\nof time to see if there are any more results."), "event_type": z.array(z.enum(["ACCESS_GRANTED","ACCESS_REVOKED","ADD_DEVICE_ASSOCIATION","ADD_LOGIN_ACTIVITY_DEVICE","ADMIN_LOGIN","APPLICATION_CREATED","APPLICATION_PUBLIC_KEY_ADDED","APPLICATION_PUBLIC_KEY_DELETED","CHANGE_ADMIN_ROLE","CHANGE_FOLDER_PERMISSION","COLLABORATION_ACCEPT","COLLABORATION_EXPIRATION","COLLABORATION_INVITE","COLLABORATION_REMOVE","COLLABORATION_ROLE_CHANGE","COMMENT_CREATE","COMMENT_DELETE","CONTENT_WORKFLOW_ABNORMAL_DOWNLOAD_ACTIVITY","CONTENT_WORKFLOW_AUTOMATION_ADD","CONTENT_WORKFLOW_AUTOMATION_DELETE","CONTENT_WORKFLOW_POLICY_ADD","CONTENT_WORKFLOW_SHARING_POLICY_VIOLATION","CONTENT_WORKFLOW_UPLOAD_POLICY_VIOLATION","COPY","DATA_RETENTION_CREATE_RETENTION","DATA_RETENTION_REMOVE_RETENTION","DELETE","DELETE_USER","DEVICE_TRUST_CHECK_FAILED","DOWNLOAD","EDIT","EDIT_USER","EMAIL_ALIAS_CONFIRM","EMAIL_ALIAS_REMOVE","ENTERPRISE_APP_AUTHORIZATION_UPDATE","EXTERNAL_COLLAB_SECURITY_SETTINGS","FAILED_LOGIN","FILE_MARKED_MALICIOUS","FILE_WATERMARKED_DOWNLOAD","GROUP_ADD_ITEM","GROUP_ADD_USER","GROUP_CREATION","GROUP_DELETION","GROUP_EDITED","GROUP_REMOVE_ITEM","GROUP_REMOVE_USER","ITEM_MODIFY","ITEM_OPEN","ITEM_SHARED_UPDATE","ITEM_SYNC","ITEM_UNSYNC","LEGAL_HOLD_ASSIGNMENT_CREATE","LEGAL_HOLD_ASSIGNMENT_DELETE","LEGAL_HOLD_POLICY_CREATE","LEGAL_HOLD_POLICY_DELETE","LEGAL_HOLD_POLICY_UPDATE","LOCK","LOGIN","METADATA_INSTANCE_CREATE","METADATA_INSTANCE_DELETE","METADATA_INSTANCE_UPDATE","METADATA_TEMPLATE_CREATE","METADATA_TEMPLATE_DELETE","METADATA_TEMPLATE_UPDATE","MOVE","NEW_USER","OAUTH2_ACCESS_TOKEN_REVOKE","PREVIEW","REMOVE_DEVICE_ASSOCIATION","REMOVE_LOGIN_ACTIVITY_DEVICE","RENAME","RETENTION_POLICY_ASSIGNMENT_ADD","SHARE","SHARE_EXPIRATION","SHIELD_ALERT","SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED","SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED_MISSING_JUSTIFICATION","SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED","SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED_MISSING_JUSTIFICATION","SHIELD_JUSTIFICATION_APPROVAL","SIGN_DOCUMENT_ASSIGNED","SIGN_DOCUMENT_CANCELLED","SIGN_DOCUMENT_COMPLETED","SIGN_DOCUMENT_CONVERTED","SIGN_DOCUMENT_CREATED","SIGN_DOCUMENT_DECLINED","SIGN_DOCUMENT_EXPIRED","SIGN_DOCUMENT_SIGNED","SIGN_DOCUMENT_VIEWED_BY_SIGNED","SIGNER_DOWNLOADED","SIGNER_FORWARDED","STORAGE_EXPIRATION","TASK_ASSIGNMENT_CREATE","TASK_ASSIGNMENT_DELETE","TASK_ASSIGNMENT_UPDATE","TASK_CREATE","TASK_UPDATE","TERMS_OF_SERVICE_ACCEPT","TERMS_OF_SERVICE_REJECT","UNDELETE","UNLOCK","UNSHARE","UPDATE_COLLABORATION_EXPIRATION","UPDATE_SHARE_EXPIRATION","UPLOAD","USER_AUTHENTICATE_OAUTH2_ACCESS_TOKEN_CREATE","WATERMARK_LABEL_CREATE","WATERMARK_LABEL_DELETE"]).describe("An event type that can be filtered by")).describe("A comma-separated list of events to filter by. This can only be used when\nrequesting the events with a `stream_type` of `admin_logs` or\n`adming_logs_streaming`. For any other `stream_type` this value will be\nignored.").optional(), "created_after": z.string().datetime({ offset: true }).describe("The lower bound date and time to return events for. This can only be used\nwhen requesting the events with a `stream_type` of `admin_logs`. For any\nother `stream_type` this value will be ignored.").optional(), "created_before": z.string().datetime({ offset: true }).describe("The upper bound date and time to return events for. This can only be used\nwhen requesting the events with a `stream_type` of `admin_logs`. For any\nother `stream_type` this value will be ignored.").optional() }).optional() }).shape